\label{chap:pdp_protocol}

%$FIXME: wrong now
This chapter discusses the underlying communication details of the packetized display protocol (PDP) architecture. First, it gives an overview of the protocol design methodology. Followed by a discussion of the generalized packet format. Finally, it discusses individual packet types. The central purpose of this chapter is to provide the reader with an understanding of the reasoning behind design decisions, as well as, to provide a detailed specification of the protocol.

\section{Design Methodology}
    This section discusses the design methodology for the PDP Protocol which began with a number of critical design goals. An attempt to address the goals is not presented directly here, but discussed  elsewhere due to it being a complex topic with many interwoven aspects. The design goals are as follows:

    \begin{enumerate}
        \item {\em To design a scalable display system that is distributable and hardware agnostic.} The display protocols and interfaces utilized within projector systems have systematic issues with remaining up to date with current technology in that old standards (such as DVI) continue to be utilized due to the inability for custom synchronization solutions to work with newer hardware, as well as, due to the costs and time associated with implementing newer solutions utilizing newer standards. This will be touched upon throughout this chapter and Chapter~\ref{chap:machine_model}.
        \item {\em To provide a protocol that is relatively simple to implement without unnecessary complexity to ease the encoding and decoding process.} A low overhead and fast decode process is crucial to ensuring latency is sub-frame\footnote{This refers to latency of that below the time it would take to buffer an entire frame. Which is a common synchronization method utilized in projector systems.} across an end-to-end system. Additionally, simplifying these processes also eases potential hardware implementation mistakes, as well as, inefficiencies that could lead to reduced performance. This will be touched upon in Chapters~\ref{sec:packet_format}~and~\ref{sec:packet_types}.
        \item {\em To provide dynamic intra-frame variable refresh rate (VRR) in order to enable better bandwidth utilization.} In particular, to allow for regions of a display to be intelligently updated at different rates when driven by a scene generator. This will be touched upon in Chapter~\ref{sec:multi_framerate_performance}.
        \item {\em To provide a path to utilize classical display protocol streams such as HDMI as a backwards compatible tranport layer for PDP without introducing overhead.} This is to allow for interoperability where necessary when utilizing classical display sources, and to ease migration to a PDP based system. This will be touched upon in Chapters~\ref{sec:packet_format},~\ref{sec:packet_types},~and~\ref{chap:implementation}.
    \end{enumerate}

    For methodology, each goal was considered when making decisions about what should and should not be part of the PDP protocol, and where the boundaries of the protocol should lie. This included such decisions as how to incorporate hardware specific features, the best method to support VRR without constraining the methods by which users can implement support for it within scene generators\footnote{VRR implemented within HDMI and DisplayPort is driver controlled and thus the user has no ability to control it.}, and how to ease implementation in current and future hardware. Hardware specific optimizations can be important for performance reasons even in hardware agnostic protocols. Therefore, it is paramount to make hardware agnostic protocols general enough to support various configurations. For example, tuning within TCP\cite{WeigleFeng2002} is a well known important consideration in the field of networks for maximizing throughput due to differing hardware and network topologies. In PDP, one example would be to support different array write processes\footnote{See Chapter~\ref{chap:array_write_process} for the interleaved array write process of the TCSA, NSLEDS and HDILED arrays.} as efficient ordering of data is important for low latency operation and minimizing hardware complexity.

\section{Comparison}

    In order to better understand how to design PDP, the constraints of classical display protocols were investigated to discern which features within these protocols conflict with the design goals of PDP. In addition, it was necessary to investigate whether these could provide a path forward in the design and development of PDP. Many versions of these protocols (DVI\cite{DDWG1999}, HDMI\cite{HDMIForum2018}, DisplayPort\cite{VESA2016}, etc.) provide similar feature-sets to end-users with the major focus being on increasing refresh rates and resolutions with each new specification. However, as discussed in Chapter~\ref{sec:classical_display_protocols}, their basis is rooted in the classical analog video specifications that utilize scan lines\cite{Neal1998}. This means, that signal timing utilizes vertical and horizontal blanking periods that consist of a front-porches, sync pulses, and back-porches; in addition to, the active video data to be displayed.

    For early analog display devices, these signals enabled operators to manually adjust horizontal and vertical hold times relative to the sync pulses in order to correct for the imprecise timing of early display hardware; but provide little benefit on modern hardware other than as an embedded method to support sending frames at a static interval, and to enable tearless buffer swapping in either double buffering\cite{FriedbergEtAl1990} or triple buffering schemes\cite{3dfx1997} utilized within GPUs\footnote{This is performed by swapping buffers during the vertical sync (vsync) interval of a frame\cite{3dfx1999,3dfx1999_2}. See Chapter~\ref{chap:display_protocols} for details about the vsync interval.}.

    In digital display technology, this represents an anachronism that impedes the goal of maximizing bandwidth utilization when driving a display by requiring the transmission of unnecessary data over the digital protocol. For example, a commonly utilized 1920 by 1080 pixel mode operating at \mbox{60 Hz}\cite{MythTVWebsite} on a modern display has a 16 percent blanking period overhead due to the specification of vertical and horizontal sync periods. Other examples can be seen in Table~\ref{tbl:modeline_overhead}. Of note, modes with {\it 512 by 512} and {\it 512 by 256} visible pixels are non-standard and were tested on existing hardware in order to minimize the overhead of blanking. Additionally, these have been utilized within NSLEDS and TCSA during actual array operation. What one sees is that as modelines shrink and data rates decrease higher percentages of blanking is required relative to displayed pixels. This is due to the inability for common implementations of video decoders to operate correctly when blanking is minimized. An additional larger issue is that when non-standard visible resolutions are utilized many decoders do not operate at all.

    \begin{table}
        \centering
        \large
        \begin{tcolorbox}[tabularx={Y|Y|Y|Y|Y},title=\textbf{Modeline Overhead},boxrule=0.5pt]
        \textbf{\normalsize Resolution} & \textbf{\normalsize Refresh Rate (Hz)} & \textbf{\normalsize Visible Pixels} & \textbf{\normalsize Total Pixels} & \textbf{\normalsize Overhead} \\ \hline
            \textbf{\normalsize 1920x1080} & \textbf{\normalsize 60}   & {\normalsize 2073600} & {\normalsize 2475000} & {\normalsize 16.2\%} \\ \hline
            \textbf{\normalsize 1600x1200} & \textbf{\normalsize 60}   & {\normalsize 1920000} & {\normalsize 2700000} & {\normalsize 28.9\%} \\ \hline
            \textbf{\normalsize 1280x1024} & \textbf{\normalsize 60}   & {\normalsize 1310720} & {\normalsize 1799408} & {\normalsize 27.2\%} \\ \hline
            \textbf{\normalsize 1280x960}  & \textbf{\normalsize 60}   & {\normalsize 1228800} & {\normalsize 1800000} & {\normalsize 31.7\%} \\ \hline
            \textbf{\normalsize 1280x800}  & \textbf{\normalsize 60}   & {\normalsize 1024000} & {\normalsize 1391040} & {\normalsize 26.4\%} \\ \hline
            \textbf{\normalsize 1024x768}  & \textbf{\normalsize 60}   & {\normalsize 786432 } & {\normalsize 1083264} & {\normalsize 27.4\%} \\ \hline
            \textbf{\normalsize 512x512}   & \textbf{\normalsize 500}  & {\normalsize 262144 } & {\normalsize 296100 } & {\normalsize 11.5\%} \\ \hline
            \textbf{\normalsize 512x512}   & \textbf{\normalsize 400}  & {\normalsize 262144 } & {\normalsize 296100 } & {\normalsize 11.5\%} \\ \hline
            \textbf{\normalsize 512x512}   & \textbf{\normalsize 300}  & {\normalsize 262144 } & {\normalsize 357500 } & {\normalsize 26.7\%} \\ \hline
            \textbf{\normalsize 512x512}   & \textbf{\normalsize 100}  & {\normalsize 262144 } & {\normalsize 357500 } & {\normalsize 26.7\%} \\ \hline
            \textbf{\normalsize 512x512}   & \textbf{\normalsize 60}   & {\normalsize 262144 } & {\normalsize 357500 } & {\normalsize 26.7\%} \\ \hline
            \textbf{\normalsize 512x512}   & \textbf{\normalsize 50}   & {\normalsize 262144 } & {\normalsize 364000 } & {\normalsize 28.0\%} \\ \hline
            \textbf{\normalsize 512x512}   & \textbf{\normalsize 30}   & {\normalsize 262144 } & {\normalsize 520000 } & {\normalsize 50.0\%} \\ \hline
            \textbf{\normalsize 512x512}   & \textbf{\normalsize 30}   & {\normalsize 262144 } & {\normalsize 520000 } & {\normalsize 50.0\%} \\ \hline
            \textbf{\normalsize 512x256}   & \textbf{\normalsize 1000} & {\normalsize 131072 } & {\normalsize 149460 } & {\normalsize 12.3\%} \\ \hline
            \textbf{\normalsize 512x256}   & \textbf{\normalsize 500}  & {\normalsize 131072 } & {\normalsize 256000 } & {\normalsize 48.8\%} \\ \hline
            \textbf{\normalsize 512x256}   & \textbf{\normalsize 200}  & {\normalsize 131072 } & {\normalsize 320000 } & {\normalsize 59.0\%} \\ \hline
            \textbf{\normalsize 512x256}   & \textbf{\normalsize 100}  & {\normalsize 131072 } & {\normalsize 320000 } & {\normalsize 59.0\%} \\ \hline
            \textbf{\normalsize 512x256}   & \textbf{\normalsize 60}   & {\normalsize 131072 } & {\normalsize 320000 } & {\normalsize 59.0\%} \\ \hline
        \end{tcolorbox}
        \caption[Modeline Overhead]{Modeline overhead for various resolutions and refresh rates\cite{MythTVWebsite}. Computed using active pixel area over total pixel area. 512x512 and 512x256 are typical modeline resolutions used on IRLED arrays.}
        \label{tbl:modeline_overhead}
    \end{table}

    These protocols also internally utilize a mode based display of data that requires the specification of the absolute width and height of display, as well as, a pixel clock which when used in conjunction with the vertical blanking information provides a total refresh rate as described in Chapter~\ref{sec:classical_display_protocols}. This means that the bandwidth requirements for a given mode are inherently static across all frames. In addition, this constrains the refresh rate for a display to be static in terms of both the intra-frame regions of the display and between frames. Effectively increasing the burden of synchronization, and impeding the introduction of dynamism into the display process.

    In recent years, work has been done to implement a limited form of variable refresh rate (VRR) display between frames for use with newer protocols\cite{AMDFreesync,NVIDIAGsync}. In essence, it allows for entire frames to be sent for display immediately once the rendering process has completed. The downside is that this generally requires specialized hardware support out of the scope of protocol specifications. A recent update of the HDMI 2.1 specification\cite{HDMIForum2018} seeks to integrate speed-limited form of VRR directly into the specification, and requires full frames of data to be transmitted at a statically specified resolution and target framerate. DisplayPort provides a similar form of VRR\cite{VESA2014} with a similar set of limitations which also require full frames of data to be transmitted at a specified resolution and target framerate.

    DisplayPort differs from older display standards in that data streams themselves are framed\cite{VESA2011,Wiley2011}, though the standard itself refers to this framing as packetization it differs from the normal sense of packets in that arbitrary packets of data with dynamic meanings and decoding cannot be sent. An example of the framing is shown in Figure~\ref{fig:display_port_framing}. Once per frame in between pixel data, a blanking start symbol is inserted into the data stream to indicate the start of vertical blanking. Then, a Main Stream Data (MSA) packet containing the total number of horizontal pixels per line, the total number lines, the start of active video pixels relative to hsync, the start of active lines relative to vsync, and the pixel formating is sent. After which, a blanking end symbol is inserted to indicate the end of vertical blanking. Following this, pixel data conforming to the video specification within the MSA packet is sent along with stuffing symbols that are framed with fill start and end symbols. These can be of different lengths and are used to represent space between actual data. After all of the data for a frame is sent, blanking symbols for the next frame occur, and the process repeats. In essence, what DisplayPort provides is a framed method of sending video formatting information per frame instead of embedding these signals in a separate synchronized stream. Display port also provides a secondary stream to send audio or other information (not shown) during the blanking interval similar to how blanking intervals are sometimes used as a sidechannel for extra data in earlier protocols.

    \begin{figure}
        \centering
        \includegraphics[width=1.0\textwidth]{fig/display_port_framing.pdf}
        \caption{Display Port Framing}
        \label{fig:display_port_framing}
    \end{figure}

    This differs from PDP in that PDP allows for completely arbitrary packets to be sent and decoded with differing packet sizes which enables PDP with the ability to support dynamic sub-frame framerates, and to be extendable for future packet types. Additionally, PDP carries no internal notion of horizontal or vertical blanking intervals which allows PDP to operate as fast as possible and give scene generators direct control over framerates at the user level. For example, the transport upon which PDP is implemented can operate at the maximum possible data rate allowable in hardware; then, the user in turn simply sends packets over the data link at the desired rate inserting empty space where necessary. In the backend, a PDP decoder would decode the data as quickly as possible and display it. From a higher level, this could be viewed as the user simply issuing commands to send data packets similar to that of how TCP based programs send data over a link with a remote environment executing the actual commands. It is up to the user where and when they want data displayed.

\section{Overhead}
    As mentioned previously, internally PDP has no notion of blanking periods or porches for providing synchronization, and therefore does not encapsulate the inefficiencies inherent in the aforementioned protocols. Instead synchronization and framerates within PDP are controlled by the source through timing when data is sent. This means the high overheads due to blanking can be mitigated. Table~\ref{tbl:pdp_efficiency} shows the maximum packet overhead due to packet encapsulation when PDP is utilized for the same resolutions and frequencies listed in Table~\ref{tbl:modeline_overhead}.

    \begin{table}
        \centering
        \large
        \begin{tcolorbox}[tabularx={Y|Y|Y|Y|Y|Y},title=\textbf{PDP Maximum Packet Overhead},boxrule=0.5pt]
        \textbf{\normalsize Slow Refresh Rate (Hz)} & \textbf{\normalsize Fast Refresh Rate (Hz)} & \textbf{\normalsize Visible Pixels} & \textbf{\normalsize Total Pixels} & \textbf{\normalsize Overhead} & \textbf{\normalsize Overhead Reduction} \\ \hline
            \textbf{\normalsize 1920x1080} & \textbf{\normalsize 60}   & {\normalsize 2073600} & {\normalsize 2235600} & {\normalsize 7.2\%} &\textbf{\normalsize 9.0 \%} \\ \hline
            \textbf{\normalsize 1600x1200} & \textbf{\normalsize 60}   & {\normalsize 1920000} & {\normalsize 2070000} & {\normalsize 7.2\%} &\textbf{\normalsize 21.7\%} \\ \hline
            \textbf{\normalsize 1280x1024} & \textbf{\normalsize 60}   & {\normalsize 1310720} & {\normalsize 1413120} & {\normalsize 7.2\%} &\textbf{\normalsize 20.0\%} \\ \hline
            \textbf{\normalsize 1280x960}  & \textbf{\normalsize 60}   & {\normalsize 1228800} & {\normalsize 1324800} & {\normalsize 7.2\%} &\textbf{\normalsize 24.5\%} \\ \hline
            \textbf{\normalsize 1280x800}  & \textbf{\normalsize 60}   & {\normalsize 1024000} & {\normalsize 1104000} & {\normalsize 7.2\%} &\textbf{\normalsize 19.2\%} \\ \hline
            \textbf{\normalsize 1024x768}  & \textbf{\normalsize 60}   & {\normalsize 786432 } & {\normalsize 847872 } & {\normalsize 7.2\%} &\textbf{\normalsize 20.2\%} \\ \hline
            \textbf{\normalsize 512x512}   & \textbf{\normalsize 500}  & {\normalsize 262144 } & {\normalsize 282624 } & {\normalsize 7.2\%} &\textbf{\normalsize 4.3\% } \\ \hline
            \textbf{\normalsize 512x512}   & \textbf{\normalsize 400}  & {\normalsize 262144 } & {\normalsize 282624 } & {\normalsize 7.2\%} &\textbf{\normalsize 4.3\% } \\ \hline
            \textbf{\normalsize 512x512}   & \textbf{\normalsize 300}  & {\normalsize 262144 } & {\normalsize 282624 } & {\normalsize 7.2\%} &\textbf{\normalsize 19.5\%} \\ \hline
            \textbf{\normalsize 512x512}   & \textbf{\normalsize 100}  & {\normalsize 262144 } & {\normalsize 282624 } & {\normalsize 7.2\%} &\textbf{\normalsize 19.5\%} \\ \hline
            \textbf{\normalsize 512x512}   & \textbf{\normalsize 60}   & {\normalsize 262144 } & {\normalsize 282624 } & {\normalsize 7.2\%} &\textbf{\normalsize 19.5\%} \\ \hline
            \textbf{\normalsize 512x512}   & \textbf{\normalsize 50}   & {\normalsize 262144 } & {\normalsize 282624 } & {\normalsize 7.2\%} &\textbf{\normalsize 20.8\%} \\ \hline
            \textbf{\normalsize 512x512}   & \textbf{\normalsize 30}   & {\normalsize 262144 } & {\normalsize 282624 } & {\normalsize 7.2\%} &\textbf{\normalsize 42.8\%} \\ \hline
            \textbf{\normalsize 512x512}   & \textbf{\normalsize 30}   & {\normalsize 262144 } & {\normalsize 282624 } & {\normalsize 7.2\%} &\textbf{\normalsize 42.8\%} \\ \hline
            \textbf{\normalsize 512x256}   & \textbf{\normalsize 1000} & {\normalsize 131072 } & {\normalsize 141312 } & {\normalsize 7.2\%} &\textbf{\normalsize 5.1\% } \\ \hline
            \textbf{\normalsize 512x256}   & \textbf{\normalsize 500}  & {\normalsize 131072 } & {\normalsize 141312 } & {\normalsize 7.2\%} &\textbf{\normalsize 41.6\%} \\ \hline
            \textbf{\normalsize 512x256}   & \textbf{\normalsize 200}  & {\normalsize 131072 } & {\normalsize 141312 } & {\normalsize 7.2\%} &\textbf{\normalsize 51.8\%} \\ \hline
            \textbf{\normalsize 512x256}   & \textbf{\normalsize 100}  & {\normalsize 131072 } & {\normalsize 141312 } & {\normalsize 7.2\%} &\textbf{\normalsize 51.8\%} \\ \hline
            \textbf{\normalsize 512x256}   & \textbf{\normalsize 60}   & {\normalsize 131072 } & {\normalsize 141312 } & {\normalsize 7.2\%} &\textbf{\normalsize 51.8\%} \\ \hline
        \end{tcolorbox}
        \caption[PDP Maximum Packet Overhead]{Maximum PDP Packet Overhead for various resolutions and refresh rates in PDP. Computed using active pixel area over total pixel area. The right column shows the reduction in overhead vs normal modelines. 512x512 and 512x256 are typical modeline resolutions used on IRLED arrays.}
        \label{tbl:pdp_efficiency}
    \end{table}

    This is computed by taking the visible resolution and dividing it by the minimum packet size supported on an array to yield the maximum possible packet count $C_{pkt}$ for a given resolution as shown in Equation~\ref{eq:packet_max}. The visible resolution parameters are denoted as horizontal active, $h_a$, and vertical active, $v_a$, respectively to keep consistent with the naming conventions used in Chapter~\ref{chap:display_protocols}. Within the NSLEDS and HDILED arrays, the minimal possible packet size denoted as $m_{pkt}$ is a 2 by 32 due to the interleaved array write process discussed in Chapter~\ref{chap:array_write_process}.

    \begin{equation}
        \begin{array}{ l }
            \displaystyle C_{pkt}=\frac{h_a \cdot v_a}{m_{pkt}} \\[13pt]
            \displaystyle C_{pkt}=\frac{h_a \cdot v_a}{2 \cdot 32}
        \end{array}
        \label{eq:packet_max}
    \end{equation}

    The total pixel overhead, $O_{px}$, is computed by multiplying the total packet count, $C_{pkt}$, by the packet overhead, $O_{pkt}$, as shown in Equation~\ref{eq:overhead_pixel}. The overhead is determined by looking at the total number of additional words added for PDP header data. Header details are discussed in Chapter~\ref{sec:packet_format}.

    \begin{equation}
        \begin{array}{ l }
            \displaystyle O_{px}=O_{pkt} \cdot C_{pkt} \\
            \displaystyle O_{px}=5\cdot C_{pkt}
        \end{array}
        \label{eq:overhead_pixel}
    \end{equation}

    The total pixel count, $T_{px}$, is determined by adding the total pixel overhead, $O_{px}$ or the result of Equation~\ref{eq:overhead_pixel} to the visible pixel size as shown in Equation~\ref{eq:total_pixel}.

    \begin{equation}
        \begin{array}{ l }
            \displaystyle T_{px}=O_{pkt} \cdot C_{pkt} + h_a \cdot v_a \\
            \displaystyle T_{px}=O_{px} + h_a \cdot v_a \\
            \displaystyle T_{px}=5\cdot C_{pkt} + h_a \cdot v_a \\[13pt]
        \end{array}
        \label{eq:total_pixel}
    \end{equation}

    Putting the input variables together and simplifying yields Equation~\ref{eq:total_pixel2} where $T_{px}$ is the total pixels.

    \begin{equation}
        \begin{array}{ l }
            \displaystyle T_{px}=O_{pkt} \cdot \frac{h_a \cdot v_a}{m_{pkt}} + h_a \cdot v_a \\[13pt]
            \displaystyle T_{px}=h_a \cdot v_a \cdot (\frac{O_{pkt}}{m_{pkt}} + 1) \\[13pt]
            \displaystyle T_{px}=h_a \cdot v_a \cdot (\frac{5}{2 \cdot 32} + 1)
        \end{array}
        \label{eq:total_pixel2}
    \end{equation}

    To compute overhead percentage is simply a matter of dividing the total pixel overhead, $O_{px}$ by the total pixels, $T_{px}$.

    \begin{equation}
        \begin{array}{ l }
            \displaystyle O_{\%}=\frac{O_{pkt}\cdot C_{pkt}}{T_{px}} \cdot 100 \\[13pt]
            \displaystyle O_{\%}=\frac{O_{px}}{T_{px}} \cdot 100 \\[13pt]
        \end{array}
        \label{eq:overhead}
    \end{equation}

    Due to the nature of the total pixel overhead being proportional to the visible pixel size for each resolution, the overhead percentage cancels out to be a constant consisting of only a relationship between the minimum packet size and packet overhead.

    \begin{equation}
        \begin{array}{ l }
            \displaystyle O_{\%}=\frac{O_{pkt}\cdot \frac{h_a \cdot v_a}{m_{pkt}}}{O_{pkt} \cdot \frac{h_a \cdot v_a}{m_{pkt}} + h_a \cdot v_a} \cdot 100 \\[16pt]
            \displaystyle O_{\%}=\frac{O_{pkt}\cdot \frac{\cancelto{1}{h_a \cdot v_a}}{m_{pkt}}}{O_{pkt} \cdot \frac{\cancelto{1}{h_a \cdot v_a}}{m_{pkt}} + \cancelto{1}{h_a \cdot v_a}} \cdot 100 \\[25pt]
            \displaystyle O_{\%}=\frac{O_{pkt}\cdot \frac{1}{m_{pkt}}}{O_{pkt} \cdot \frac{1}{m_{pkt}} + 1} \cdot 100 \\[16pt]
            \displaystyle O_{\%}=\frac{\frac{O_{pkt}}{m_{pkt}}}{\frac{O_{pkt}}{m_{pkt}} + 1} \cdot 100 \\[19pt]
            \displaystyle O_{\%}=\frac{\frac{5}{2 \cdot 32}}{\frac{5}{2 \cdot 32} + 1} \cdot 100 \\[13pt]
            \displaystyle O_{\%}=7.2 \\[13pt]
        \end{array}
        \label{eq:cancel}
    \end{equation}

    The overhead reduction in Table~\ref{tbl:pdp_efficiency} is computed by subtracting the PDP overhead from the overheads listed in Table~\ref{tbl:modeline_overhead}.

\section{Multi-framerate Performance}
    \label{sec:multi_framerate_performance}
    Furthermore, because PDP allows for control over individual segments a large amount of bandwidth can be saved by updating parts of a frame at slower frame rates than other sections of a frame. Equation~\eqref{eq:bandwidth_saved} shows computing the savings where $p$ is the proportion of pixels operating at a slow frame rate, $r_f$ is the fast frame rate, $r_s$ is the slow frame rate, and $b_s$ the percentage of bandwidth saved.

    \begin{equation}
        b_s=1-\frac{(1-p)\cdot r_f + p\cdot r_s}{r_f}
        \label{eq:bandwidth_saved}
    \end{equation}

        %FIXME: Add figure that shows better bandwidth utilization of PDP?
        %FIXME: Relate back to the design goals of PDP


\section{Packet Format}
    \label{sec:packet_format}
    %FIXME: REAL PROPOSAL slides 31 and 32 talk about packet considerations and details
    %slide 31:
        %- Minimize what we need
        %- Possible Solutions
            %- X, Y, Size, Variable pixel data format
            %- X start, X end, Y start, Y end, Variable pixel data format
            %- Consider the sizes of each field and resolutions
            %- Efficiency
        %- Considerations
            %- Byte alignment: Most computer architectures and HW use at-least 8-bit alignment for ISA and bus widths
            %- Computations/Comparisons needed
    %slide 32:
        %- Fix-width fields
            %- simplify decoding/processing HW and implementation
        %WORD size >= 2^16, assume power of 2
            %- 65536 by 65536 array size
            %- Need to consider pixel resolution as well
            %- Simplify operations through alignment
        %Region: X start, X end, Y start, Y end
            %- Utilize a single unified coordinate system minimize translations
            %- Reduce computational complexity in HW and compositor
                %- Avoid 2N2additional comparisons for compositing (for translation)
                %- Remove unneeded computations in back-end

    %FIXME: insert packet format from REAL PROPOSAL slide 34 and 36
        %- picture
        %- picture of classic active video frame vs pdp frame (discuss using hdmi as a transport)


\section{Packet Types}
    \label{sec:packet_types}

    Figure~\ref{fig:packets} shows the basic packets used for communication within PDP. These are strictly for data transfer and synchronization of system operations, and do not include other aspects such as system setup or enumeration\footnote{System setup and enumeration are typically system specific operations and outside of the current PDP Design, but may be incorporated in the future}. These packets are organized into type specific fields of some set word-size. The exact size of word fields is left abstracted to allow for an optimal implementation to be used in practice. For example, a system may utilize 24-bit word size if an array has a native 24-bit pixel size, or 32-bit word size if the hardware transport layer has a specific optimal word size. Typically, a multiple of 8-bit word size would be utilized in practice, as most hardware architectures (such as x86) utilize some multiple of this size. In any given implementation, the word size of all fields must match, in order to simplify decoding operations. This allows for fixed-size decoding of incoming data, which simplifies processing and firmware implementation, as well as, can ease timing constraints and enforce non-variability in the decoding time of incoming packets of data. In general, PDP packets are designed to send a minimal amount of header data to lower overhead and ordered in a way to minimize buffering requirements to enable real-time processing.

    \begin{figure}
        \centering
        \includegraphics[width=1.0\textwidth]{fig/packet_chart.pdf}
        \caption{List of PDP Packets}
        \label{fig:packets}
    \end{figure}

    In terms of the protocol itself, PDP uses a single global coordinate system to refer to pixel locations on a display array. For example, a 512 by 512 pixel array would have coordinates from 0 to 511 in both the horizontal and vertical directions. All packets referencing sub-regions of this display would utilize coordinates that map to some rectangular sub-region of the display. Any overlapping regions of data would be composited during system operation with priority given to data segments sent at higher frame rates.

    PDP Packets are segmented into three types, a draw region packet, array reset packet, and trigger packet. All packets consist of a Type ID field of word-size. The draw region packet is used to send a rectangular sub-region of pixel data in global array coordinates. It has fields for the start and stop horizontal and vertical coordinates (defined inclusively) followed by individual pixel data. For example, suppose a scene generator were to send a packet of data from array region 10 to 19 along the X axis and 20 to 29 along the Y axis, a total of 100 pixels of data would follow the packet coordinates given that the packet specifies a 100 pixel sized region.

    The second packet, array reset, is utilized to indicate that quadrants on a given array should be cleared. It consists of an array specific quadrant bit-mask used to indicate which quadrant to reset. Any unused bits are reserved. This type of packet would be utilized exclusively between compositor and array tile links.

    The third packet, trigger, is used to implement a trigger based synchronization within in PDP. It consists of a system specific action bit-mask used to indicate the type of operation to trigger. In IRLED array systems, the coordinator of synchronization is dependent on the array itself and the different components within the system. In some systems, a sensor may be used as the source of synchronization, in other systems, another component may be utilized. Other aspects of system operation may even be triggered outside of the system synchronization interval based off of other events. For the reason, PDP has opted for a trigger based approach to synchronization. This approach allows for synchronization, data transfer, and computation to be custom tailored to an individual systems use-case. For example, the action mask could be used to trigger the generation of the next frame to be displayed when needed, the source of which is defined by the system itself. Another example would be utilize the action mask to indicate that further computations (such as scene generation) stall until otherwise indicated.

\section{PDP Frames}
    %FIXME: insert picture from slide 38 of real proposal
